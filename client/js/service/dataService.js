'use strict';

/**
 * Data Service provides an interface allowing JS modules to get data.
 * @class
 * @example
app.service('dataService', [
    '$rootScope',
    '$http',
    'performanceService',
    'urlParameterService',
    DataService
]);
 */
class DataService {
    /**
     * @param {object} $rootScope {@link https://docs.angularjs.org/api/ng/service/$rootScope}
     * @param {object} $http {@link https://docs.angularjs.org/api/ng/service/$http}
     * @param {PerformanceService} performanceService
     * @param {UrlParameterService} urlParameterService
     */
    constructor($rootScope, $http, performanceService, urlParameterService) {
        this.$rootScope = $rootScope;
        this.$http = $http;
        this.performanceService = performanceService;
        this.urlParameterService = urlParameterService;

        /**
         * If internal data source is ready.
         * This variable is set to ```false``` at startup, then changed to ```true``` when data is downloaded.
         * May be used for functions to prevent queries that happened before data is downloaded.
         * @type {boolean}
         * @private
         */
        this.isReady = false;

        /**
         * List of all subjects.
         * Before the data is downloaded, this variable is initialized to empty.
         * When data is downloaded, this variable is set to contain data and is never changed thereafter.
         * The list is sorted by 'subject' field.
         * @type {Subject[]}
         * @private
         */
        this.subjects = [];

        /**
         * List of all courses.
         * Before the data is downloaded, this variable is initialized to empty.
         * When data is downloaded, this variable is set to contain data and is never changed thereafter.
         * The list is not sorted, but the index of elements are fixed at data generation and elements should not be moved around.
         * @type {Course[]}
         * @private
         */
        this.courses = [];

        /**
         * List of all sections.
         * Before the data is downloaded, this variable is initialized to empty.
         * When data is downloaded, this variable is set to contain data and is never changed thereafter.
         * The list is sorted by 'crn' field, and the index of elements are fixed at data generation and elements should not be moved around.
         * @type {Section[]}
         * @private
         */
        this.sections = [];

        /**
         * List of all instructors.
         * Before the data is downloaded, this variable is initialized to empty.
         * When data is downloaded, this variable is set to contain data and is never changed thereafter.
         * The list is sorted by 'name' field.
         * @type {Instructor[]}
         * @private
         */
        this.instructors = [];

        /**
         * Timestamp of when the data was generated.
         * It is generated by a call to Python ```datetime.now().timestamp()```.
         * The measurement is in milliseconds since epoch.
         * @type {number}
         * @private
         */
        this.timestamp = 0;

        // Download semester meta file then download actual data file.
        // Using .bind(this) to ensure correct this pointer
        performanceService.start('dataService.$http.get()');
        // TODO: Accurately determine default semester when parameter is not provided.
        this.semester = urlParameterService.get('semester');
        if (this.semester == undefined) {
            this.semester = 'fall';
        }
        $http.get('../data/scheduleMeta.json')
            .then(this.scheduleMetaDownloadSuccess.bind(this), this.httpDownloadError.bind(this));
    }

    /**
     * Semester Meta download success handler.
     * This function is called when Semester Meta file is successfully downloaded.
     * This function initializes downloading of actual semester data.
     * @param {Promise} response
     */
    scheduleMetaDownloadSuccess(response) {
        const scheduleMeta = {
            spring: {},
            summer: {},
            fall: {}
        };

        for (const item of response.data) {
            const pair = item.title;
            scheduleMeta[pair[0]].year = pair[1];
        }

        this.scheduleMeta = scheduleMeta;

        this.$http.get(`../data/${this.semester}.json`)
            .then(this.httpDownloadSuccess.bind(this), this.httpDownloadError.bind(this))
            .finally(this.httpDownloadFinally.bind(this));
    }

    /**
     * HTTP download success handler.
     * This function is called when data file is successfully downloaded.
     * @param {Promise} response Response containing data.
     * @fires DataService#initSuccess
     * @private
     */
    httpDownloadSuccess(response) {
        Object.assign(this, response.data);
        this.isReady = true;
        this.$rootScope.$broadcast('DataService#initSuccess');
        this.$rootScope.$broadcast('serviceReady', this.constructor.name);
    }

    /**
     * HTTP download error handler.
     * This function is called when there was an error downloading data file.
     * @param {Promise} response Response containing error information.
     * @fires DataService#initError
     * @private
     */
    httpDownloadError(response) {
        this.$rootScope.$broadcast('DataService#initError', response);
    }

    /**
     * This function is always called regardless of state of the download.
     * @private
     */
    httpDownloadFinally() {
        this.performanceService.stop('dataService.$http.get()');
    }

    /**
     * Create a deep copy of an object using ```JSON.stringify()``` and ```JSON.parse()```.
     * If necessary, the ```get*()``` functions use this function to create a copy of the result to prevent possible contamination of internal data.
     * The contamination has happened before, it was painful to debug, and it shall never happen again!
     * @param {object} obj Source object.
     * @returns {object} A deep copied new object.
     * @private
     */
    copy(obj) {
        return JSON.parse(JSON.stringify(obj));
    }

    /**
     * Get the list of subjects.
     * This function is expected to return the same result every time.
     * @returns {Section[]} List of subject objects.
     */
    getSubjects() {
        return this.copy(this.subjects);
    }

    /**
     * Get a subject from the given subject name.
     * @param {string} subjectKey Name of the subject. E.g. CSE, ECE, HUM.
     * @returns {Subject} Subject object with specified subject name.
     * @returns {undefined} If subject name is not found.
     * @example const subject = dataService.getSubject('CSE');
     */
    getSubject(subjectKey) {
        const subject = this.subjects.find(
            subject => subject.subject == subjectKey,
            this
        );
        return this.copy(subject);
    }

    /**
     * Get a list of courses under specific subject.
     * @param {string} subjectKey Name of the subject. E.g. CSE, ECE, HUM.
     * @returns {Course[]} List of course objects.
     * @throws {"TypeError: undefined is not an object (evaluating 'subject.courseIdxs')"} If subject name is not found.
     * @example const courses = dataService.getCourses('CSE');
     */
    getCourses(subjectKey) {
        const subject = this.subjects.find(
            subject => subject.subject == subjectKey,
            this
        );
        const courses = subject.courseIdxs.map(
            index => this.courses[index],
            this
        );
        return courses;
    }

    /**
     * Get a course from the given subject name and course number.
     * @param {string} subjectKey Name of the subject. E.g. CSE, ECE, HUM.
     * @param {number} courseKey Course number of the course. E.g. 1001, 1502, 4130.
     * @returns {Course} Course object with specified subject and course number.
     * @throws {"TypeError: undefined is not an object (evaluating 'subject.courseIdxs')"} If subject name is not found.
     * @throws {"SyntaxError: JSON Parse error: Unexpected identifier \"undefined\""} If course number is not found.
     * @example const course = dataService.getCourse('CSE', 1001);
     */
    getCourse(subjectKey, courseKey) {
        const subject = this.subjects.find(
            subject => subject.subject == subjectKey,
            this
        );
        const courseIndex = subject.courseIdxs.find(
            index => this.courses[index].course == courseKey,
            this
        );
        const course = this.courses[courseIndex];
        return this.copy(course);
    }

    /**
     * Get a list of section objects from subject name and course number.
     * @param {string} subjectKey Name of the subject. E.g. CSE, ECE, HUM.
     * @param {number} courseKey Course number of the course. E.g. 1001, 1502, 4130.
     * @returns {Section[]} List of section objects.
     * @throws {"TypeError: undefined is not an object (evaluating 'subject.courseIdxs')"} If subject name is not found.
     * @throws {"TypeError: undefined is not an object (evaluating 'this.courses[courseIndex].sectionIdxs')"} If course number is not found.
     * @example const sections = dataService.getSections('CSE', 1001);
     */
    getSections(subjectKey, courseKey) {
        const subject = this.subjects.find(
            subject => subject.subject == subjectKey,
            this
        );
        const courseIndex = subject.courseIdxs.find(
            index => this.courses[index].course == courseKey,
            this
        );
        const sectionIndexes = this.courses[courseIndex].sectionIdxs;
        const sections = sectionIndexes.map(
            index => this.sections[index],
            this
        );
        return sections;
    }

    /**
     * Get a list of section CRNs from the given subject name and course number.
     * @param {string} subjectKey Name of the subject. E.g. CSE, ECE, HUM.
     * @param {number} courseKey Course number of the course. E.g. 1001, 1502, 4130.
     * @returns {number[]} List of section CRNs.
     * @throws {"TypeError: undefined is not an object (evaluating 'subject.courseIdxs')"} If subject name is not found.
     * @throws {"TypeError: undefined is not an object (evaluating 'this.courses[courseIndex].sectionIdxs')"} If course number is not found.
     * @example const sectionCrns = dataService.getSectionCrns('CSE', 1001);
     */
    getSectionCrns(subjectKey, courseKey) {
        const subject = this.subjects.find(
            subject => subject.subject == subjectKey,
            this
        );
        const courseIndex = subject.courseIdxs.find(
            index => this.courses[index].course == courseKey,
            this
        );
        const sectionIndexes = this.courses[courseIndex].sectionIdxs;
        const sectionCrns = sectionIndexes.map(
            index => this.sections[index].crn,
            this
        );
        return sectionCrns;
    }

    /**
     * Get a section object from the given CRN.
     * This function is optimized with binary search and depends on the list being sorted.
     * @param {number} crn CRN of the section. E.g. 17364, 23716, 26655.
     * @returns {Section} Section object with specified CRN.
     * @returns {undefined} If CRN is not found.
     * @example const section = dataService.getSection(17364);
     */
    getSection(crn) {
        let l = 0;
        let r = this.sections.length - 1;

        while (l <= r) {
            const m = Math.floor((l + r) / 2);
            const section = this.sections[m];

            if (section.crn == crn) {
                return this.copy(section);
            }

            if (section.crn < crn) {
                l = m + 1;
            } else {
                r = m - 1;
            }
        }

        return undefined;
    }

    /**
     * Get the list of all sections.
     * This function is expected to return the same result every time.
     * @returns {Section[]} List of all section objects.
     * @example const sections = dataService.getAllSections();
     */
    getAllSections() {
        return this.copy(this.sections);
    }

    /**
     * Get an instructor object from the given instructor name.
     * This function is optimized with binary search and depends on the list being sorted.
     * @param {string} name Instructor name. Case insensitive.
     * @returns {Instructor} Instructor object with specified instructor name.
     * @returns {undefined} If instructor name is not found.
     * @example const instructor = dataService.getInstructor('Xu');
     */
    getInstructor(name) {
        name = name.toUpperCase();

        let l = 0;
        let r = this.instructors.length - 1;

        while (l <= r) {
            const m = Math.floor((l + r) / 2);
            const instructor = this.instructors[m];
            const nameUpperCase = instructor.name.toUpperCase();

            switch (name.localeCompare(nameUpperCase)) {
                case -1:
                    r = m - 1;
                    break;
                case 0:
                    return this.copy(instructor);
                case 1:
                    l = m + 1;
                    break;
            }
        }

        return undefined;
    }

    /**
     * Get a list of section objects under given instructor name.
     * This function is optimized with binary search and depends on the list being sorted.
     * @param {string} name Instructor name.
     * @returns {Section[]} List of section objects.
     * @returns {undefined} If instructor name is not found.
     * @example const sections = dataService.getInstructorSections('Xu');
     */
    getInstructorSections(name) {
        name = name.toUpperCase();

        let l = 0;
        let r = this.instructors.length - 1;

        while (l <= r) {
            const m = Math.floor((l + r) / 2);
            const instructor = this.instructors[m];
            const nameUpperCase = instructor.name.toUpperCase();

            switch (name.localeCompare(nameUpperCase)) {
                case -1:
                    r = m - 1;
                    break;
                case 0:
                    const sections = instructor.sectionIdxs.map(
                        index => this.sections[index],
                        this
                    );
                    sections.sort(
                        function compare(a, b) {
                            if (a.subject != b.subject) {
                                return a.subject.localeCompare(b.subject);
                            }
                            if (a.course != b.course) {
                                return a.course - b.course;
                            }
                            return a.crn - b.crn;
                        }
                    );
                    return sections;
                case 1:
                    l = m + 1;
                    break;
            }
        }

        return undefined;
    }

    /**
     * Randomly select a section that satisfies the callback function.
     * The callback function will be called up to ```upperLimit``` times until a section is found.
     * @param {function(section): boolean} [callback=()=>true] Callback function that judges the selection. The default callback function always selects whichever sections comes up first.
     * @param {number} [upperLimit=10000] Maximum numbers of trials.
     * @returns {Section} Section object.
     * @returns {undefined} If maximum numbers of trials has been reached.
     * @example const section = dataService.getRandomSection();
     */
    getRandomSection(callback = () => true, upperLimit = 10000) {
        let section;
        // Keep picking section until callback returns true
        do {
            // Randomly select a section
            section = this.sections[Math.floor(Math.random() * this.sections.length)];
        } while (!callback(section) && --upperLimit > 0);

        if (upperLimit == 0) {
            return undefined;
        }

        return this.copy(section);
    }

    /**
     * Get the timestamp of when the data was generated.
     * This function is expected to return the same result every time.
     * @returns {Date} Date object initialized with timestamp.
     * @example const timestamp = dataService.getTimestamp();
     * @see {@link https://docs.python.org/3/library/datetime.html#datetime.datetime.timestamp}
     */
    getTimestamp() {
        return new Date(this.timestamp * 1000);
    }

    /**
     * Get the timestamp of when the data was generated.
     * This function is expected to return the same result every time.
     * @returns {number} Time in actual number.
     * @example const timestamp = dataService.getTimestampNumber();
     * @see {@link https://docs.python.org/3/library/datetime.html#datetime.datetime.timestamp}
     */
    getTimestampNumber() {
        return this.timestamp;
    }

    /**
     * Get basic information of currently loaded semester.
     * @returns {SemesterMeta} Object containing information of currently loaded semester.
     */
    getSemesterMeta() {
        const meta = {
            year: this.scheduleMeta[this.semester].year,
            semester: this.semester
        };
        return this.copy(meta);
    }
}

app.service('dataService', [
    '$rootScope',
    '$http',
    'performanceService',
    'urlParameterService',
    DataService
]);

/**
 * Object that stores information about an instructor.
 * @typedef {object} Instructor
 * @property {string} name Name of the instructor.
 * @property {number[]} sectionIdxs Indexes of the sections taught by the instructor. Used internally.
 */

/**
 * Object that stores information about a subject.
 * @typedef {object} Subject
 * @property {number[]} courseIdxs Indexes of the courses under the subject. Used internally.
 * @property {string} subject Also called Prefix. E.g. CSE, ECE, HUM.
 * @property {string} title Full name of the subject. E.g. Computer Sciences.
 */

/**
 * Object that stores information about a course.
 * @typedef {object} Course
 * @property {number} course Course number of the course. E.g. 1001, 1502, 4130.
 * @property {number[]} cr Lower and upper limit of credit hours.
 * @property {string} description Description of the course.
 * @property {string} subject Subject of the course. E.g. CSE, ECE, HUM.
 * @property {string[][]} tags List of pairs of tags. [0] = Short name. [1] = Full name.
 * @property {string} title Title of the course. E.g. Fund of Software Dev 1.
 */

/**
 * Object that stores information about a section.
 * @typedef {object} Section
 * @property {number[]} cap Actual enroll and maximum enroll of the section.
 * @property {number} course Course number of the section. E.g. 1001, 1502, 4130.
 * @property {number[]} cr Lower and upper limit of credit hours.
 * @property {number} crn CRN of the section.
 * @property {string[]} days List of days the section is held on.
 * @property {string} description Description of the section.
 * @property {string} instructor Name of the instructor that teaches the section.
 * @property {string} note Special note of the section. Usually used in specific topic sections.
 * @property {string[][]} places List of pairs of places. [0] = Building. [1] = Room.
 * @property {string} section Section string of the section. Could contain alphabets.
 * @property {string} subject Subject of the section. E.g. CSE, ECE, HUM.
 * @property {string[][]} tags List of pairs of tags. [0] = Short name. [1] = Full name.
 * @property {number[][]} times List of pairs of times. [0] = Start time. [1] = End time.
 * @property {string} title Title of the section. E.g. Fund of Software Dev 1.
 */

/**
 * Object that stores information of currently loaded semester.
 * @typedef {object} SemesterMeta
 * @property {string} year Which year.
 * @property {'spring' | 'summer' | 'fall'} semester Which season.
 */

/**
 * Date Service Initialization Success Event.
 * @event DataService#initSuccess
 * @example this.$rootScope.$broadcast('DataService#initSuccess');
 * @example $scope.$on('DataService#initSuccess', (event) => { });
 */

/**
 * Date Service Initialization Error Event.
 * @event DataService#initError
 * @property {Promise} response Promise containing error information.
 * @example this.$rootScope.$broadcast('DataService#initError', response);
 * @example $scope.$on('DataService#initError', (event, response) => { });
 */
